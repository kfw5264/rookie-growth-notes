# Redis内存
## 内存消耗在哪里？
### 内存使用统计
```bash
127.0.0.1:6379> info memory
# Memory
used_memory:893392
used_memory_human:872.45K
used_memory_rss:10334208
used_memory_rss_human:9.86M
used_memory_peak:13480240
used_memory_peak_human:12.86M
used_memory_peak_perc:6.63%
used_memory_overhead:835960
used_memory_startup:812272
used_memory_dataset:57432
used_memory_dataset_perc:70.80%
allocator_allocated:956304
allocator_active:1277952
allocator_resident:3559424
total_system_memory:1019351040
total_system_memory_human:972.13M
used_memory_lua:30720
used_memory_lua_human:30.00K
used_memory_scripts:0
used_memory_scripts_human:0B
number_of_cached_scripts:0
maxmemory:0
maxmemory_human:0B
maxmemory_policy:noeviction
allocator_frag_ratio:1.34
allocator_frag_bytes:321648
allocator_rss_ratio:2.79
allocator_rss_bytes:2281472
rss_overhead_ratio:2.90
rss_overhead_bytes:6774784
mem_fragmentation_ratio:12.12
mem_fragmentation_bytes:9481832
mem_not_counted_for_evict:634
mem_replication_backlog:0
mem_clients_slaves:0
mem_clients_normal:20504
mem_aof_buffer:640
mem_allocator:jemalloc-5.1.0
active_defrag_running:0
lazyfree_pending_objects:0
lazyfreed_objects:0
```
`info memory`命令获取内存相关指标   

| 属性名                     | 属性说明                                    |
|-------------------------|-----------------------------------------|
| used_memory             | Redis分配器分配的内存总量，也就是内部存储的所有数据内存总占有量      |
| used_memory_human       | 可读格式返回used_memory                       |
| used_memory_rss         | 从操作系统角度显示Redis进程占有的物理内存总量               | 
| used_memory_peak        | 内存使用的最大值，表示used_memory的峰值               |
| used_memory_peak_human  | 可读格式返回used_memory_peak                  | 
| used_memory_lua         | Lua引擎所消耗的内存大小                           |
| mem_fragmentation_ratio | used_memory_rss / used_memory比值，表示内存碎片率 |
| mem_allocatior          | Redis使用的内存分配器，默认为jemalloc               |

> - 当`mem_fragmentation_ratio`\>1时，说明used_memory_rss - used_memory多出的部分内存并没有用于数据存储，而是被内存碎片消耗，
> 如果两者相差很大，说明碎片率很严重。 
> - 当`mem_fragmentation_ratio`\<1时，这种情况一般是操作系统把redis内存交换到硬盘导致，由于硬盘的速度远远小于内存，Redis性能会很差，
> 甚至僵死。  

### Redis内存消耗划分  
![img.png](images/Redis内存消耗划分.png)
- 自身内存
   > 通常Redis空进程自身内存消耗较少，可以忽略不计。
- 对象内存
   > Redis占用内存最大的一块，存储所有用户数据。Redis所有数据类型都是key-value数据类型，每次创建键值对时至少创建两个类型对象:key对象和value对象。
   > 对象内存消耗可以简单理解为sizeof(key)+sizeof(value)。   
   > Redis每种value对象类型根据使用规模不同，占用内存不同。使用时要合理预估并监控value对象占用情况，避免内存溢出。   
- 缓冲内存
   > 1. 客户端缓冲：所有接入Redis服务器的TCP连接的输入输出缓冲。输入缓冲无法控制，最大空间为1G，如果超出则断开连接。输出缓冲通过参数`client-output-buffer-limit`控制。
   > 2. 复制积压区缓冲：通过`repl-backlog-size`参数设置，对于主节点，复制挤压缓冲区只有一个，因此可以设置比较大的值，避免全量复制。   
   > 3. AOF缓冲区：用于Redis重写期间保存最近写入命令，用户无法控制，内存大小取决于AOF重写时间以及写入的命令量，通常占用很小。  
- 内存碎片
   > Redis默认采用的内存分配器为jemalloc，可选的分配器还有：glibc、tcmalloc。内存分配器为了更好的管理内存，分配策略一般采用固定范围的
   > 内存块进行分配。例如保存5KB对象采用8KB内存，剩下的3KB将不能再分配给其他对象存储。   
   > - 容易出现高内存碎片的场景:  
   >   1. 频繁做跟新操作，例如频繁对已存在的键做append、setrange等更新操作。   
   >   2. 大量过期键删除，键对象过期之后，释放的空间将无法得到充分利用，导致碎片率上升。   
   > - 出现高内存碎片的解决方案:    
   >   1. 数据对齐：条件允许的情况下尽量做数据对其，比如数据尽量采用数字类型或者固定长度字符串等。   
   >   2. 安全重启：重启节点可以做到内存碎片重新整理，因此可以利用高可用框架，将碎片过高的主节点转换为从节点，进行安全重启。   

## 如何管理内存？


## 如何优化内存？

