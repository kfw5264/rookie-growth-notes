# Redis阻塞问题

## 发现阻塞
> 大量Redis超时异常。 监控方法：在应用中加入异常统计，并通过邮件/短信/微信报警，以便即使发现并处理问题。  
> Java中可以通过log4j或者logback自定义Appender编写统计异常和监控逻辑。   

## 内在原因
### API或数据结构使用不合理
> `hgetall`等数据量比较大且算法复杂度时O(n)。    
> `slowlog get {n}`获取慢查询
> 修改方向: 
>    1. 修改为低算法度的命令。   
>    2. 调整大对象，将大对象拆分为多个小对象。      
> 
> `redis-cli -h {host} -p {port} -a {auth}  --bigkeys`统计历史扫描过的最大对象便于分析优化。

### CPU饱和问题
> 指把Redis的单核CPU使用率跑到接近100%。CPU饱和会导致Redis无法处理更多的命令，严重影响吞吐量和应用方的稳定性。   
> `redis-cli -h {host} -p {port} -a {auth} --stat`查看获取当前redis的使用情况。      
> `info commandstats`统计信息分析命令不合理的开销时间。  

### 持久化相关阻塞
1. fork阻塞
   > fork命令发生在RDB和AOF重写时，Redis主线程调用fork操作产生共享内存的子线程，由于进程完成持久化文件重写工作，
   > 如果fork操作本身耗时比较长，必然会导致主线程的阻塞。   

2. AOF刷盘阻塞
   > 一般情况开启AOF持久化功能时，文件刷盘方式都是一秒一次，后台线程每秒对AOF文件做fsync操作。当硬盘压力比较大时，
   > fsync需要等待，直到写入完成。如果主线程发现距离上一次fsync操作成功超过2秒，为了数据安全性它会阻塞直到fsync完成。
 
3. HugePage写操作阻塞

## 外在原因  
### CPU竞争
1. 进程竞争
   > Redis是典型的CPU密集型应用，不建议和其他CPU密集型服务部署在一起，当其他进程过度消耗CPU时，会验证影响Redis吞吐量。  
   > 解决这个问题需要调整服务之间的部署结构。   

2. 绑定CPU
   > 部署Redis为了充分利用多核CPU，通常一台机器需要部署多个实例。常见的一种优化就是把Redis进程绑定到CPU上，用于降低CPU频繁上下文切换的开销，
   > 但是当Redis父进程创建子进程进行RDB/AOF重写时，如果做了CPU绑定，会与父进程共享使用一个CPU，子进程重写对单核CPU使用率通常在90%以上，
   > 父进程与子进程产生激烈的CPU竞争，极大影响Redis的稳定性。因此对于开启持久化以及参与复制的主节点不建议绑定CPU。   

### 内存交换
   > 操作系统把一部分Redis使用的内存交换到磁盘中时，由于内存读写性能和硬盘差好几个数量级，会导致交换后的Redis性能急剧下降。   
   > - 保证机器充足的可用内存。   
   > - 确保所有Redis实例设置最大可用内存，防止极端情况下Redis内存不可控增长。   
   > - 降低系统使用swap优先级。

### 网络问题
- 拒绝连接
  - 网络闪断: 一般发生在网络割接或者带宽耗尽的情况。尽量避免客户端与Redis之间异地跨机房调用。 
  - Redis连接拒绝：
  - 连接溢出
    1. 进程限制
    2. backlog队列溢出
- 网络延迟
- 网卡软中断