# Redis进阶
## 慢查询分析
> 慢查询日志就是系统在命令执行前后计算每条命令的执行时间，当超过预设阈值，就将这条命令以及其相关信息记录下来。      
> Redis命令的生命周期: 发送命令 --> 命令排队 -->  命令执行 --> 返回结果，慢查询只统计命令执行的时间，所以没有慢查询并不代表客户端没有超时问题。    

###  慢查询配置
1. 慢查询阈值设置   
  `slowlog-log-slower-than`：单位为微秒，默认时间是10000，当命令执行时间超过10000微秒也就是10ms的时候，该命令就会被记录到慢查询日志中。如果设置为0则表示记录所有命令。如果设置<0的不进行记录。   
2. 慢查询日志存放位置   
  `slowlog-max-len`: Redis使用一个列表来记录慢查询日志，该条配置则为列表的最大长度，如果记录超出最大长度，则第一条记录出列，新的一条进入最后一个位置。
    
    > 配置方式： 
    > 1. 修改配置文件中的配置信息
    > 2. 客户端中使用config set命令配置，如果想要持久化到本地配置文件，则需要执行config rewrite命令。   

3.  获取慢查询日志    
  `slowlog get {n}`: 通过n来指定查询的条数 
      ```shell
      127.0.0.1:6379> slowlog get 2
      1) 1) (integer) 12             # 慢日志的标识ID
         2) (integer) 1677002611     # 发生的时间戳
         3) (integer) 14602          # 命令耗时
         4) 1) "slowlog"             # 执行的命令以及参数
            2) "get"
            3) "1"
         5) "127.0.0.1:37924"        # 客户端信息
         6) ""                       
      2) 1) (integer) 11
         2) (integer) 1676858661
         3) (integer) 14612
         4) 1) "ttl"
            2) "age:list"
         5) "192.168.154.1:6627"
         6) "192.168.154.128@6379"
      ```
4. 获取慢查询日志当前的长度    
  `slowlog len`：
5. 慢查询日志重置  
  `slowlog reset`  

### 最佳实践
1. 线上建议调大慢查询记录，因为记录慢查询时Redis会对长命令进行截断操作，并不会占用大量内存。
增大列表可以减缓慢查询被剔除的时间，例如线上可以设置1000以上。
2. slowlog-log-slow-than，在高QPS的情况下，命令执行时间对于系统影响比较大，这种情况下建议设置为1ms.
3. 慢查询只记录命令执行时间，因为命令排队机制，redis可能会导致其他命令级联阻塞，因此当客户端请求超时时，
需要检查该时间点是否有慢查询，从而分析是否因为慢查询导致的阻塞。 
4. 由于慢查询是一个先进先出的队列，所以当慢查询数量多的时候可能会导致部分慢查询命令丢失，可以通过定期持久化到其他存储中来记录。  
同时也可以基于此专门制作可视化界面进行查询，  

## Pipeline
> RTT(Round Trip Time 往返时间)
> 多条命令组合成一个流水线，有效节约RTT
> Redis执行命令时微妙级别，性能瓶颈时网络。

#### 最佳时间
1. 命令个数不能没有节制，否则会增加客户端等待时间，可以将一个很大的pipeline拆分成多个小的pipeline执行。 
2. 只能操作一个Redis，但是即使在分布式事务中也可以作为批量操作的重要优化手段。   

## 事务与Lua
### 事务
> 一组动作，要么全部执行，要么全部不执行。   
> 只用命令错误才会回滚，逻辑错误不支持回滚，只要命令正确都可以正常执行。
> 通过watch来确保事务中的key没有被其他客户端修改。  


### Lua脚本
> C语言开发
> 语法

#### Redis中使用Lua
1. `eval`
   ```shell
   127.0.0.1:6379> eval 脚本内容 key的个数 key列表 参数列表
   127.0.0.1:6379> eval 'return "hello " .. KEYS[1] .. " " .. ARGV[1]' 1 redis world
   "hello redis world"
   ```
   如果Lua脚本比较长，可以在客户端编写好Lua脚本代码，然后使用`redis-cli --eval`将脚本作为字符串发送给服务器，
   服务器会将执行结果返回给客户端。
2. `evalsha`  
   通过`script load`命令将脚本内容加载到Redis内存中，得到SHA1，较少每次将脚本上传到redis的开销，`evalsha`可以使用sha
   作为参数，执行逻辑同`eval`
   ```shell
   127.0.0.1:6379> evalsha sha1 numkeys key [key ...] arg [arg ...]
   ```
3. Lua的Redis API
   Lua可以通过redis.call函数实现对Redis的访问，例如：
   ```shell
   127.0.0.1:6379> eval 'return redis.call("set", KEYS[1], ARGV[1])' 1 hello redis
   OK
   127.0.0.1:6379> eval 'return redis.call("get", KEYS[1])' 1 hello
   "redis"
   ```

#### Lua的优点
1. Lua脚本执行时原子性的，中间不会插入其他语句。 
2. Lua可以帮助开发和运维人员创造自己定制的命令，并且可以保存到redis中，实现复用的效果。
3. 多条命令一次性打包，较少网络开销。

#### Redis管理Lua脚本
1. `script load script`  将脚本加载到Redis内存中
2. `script exists sha [sha ...]`  判断lua脚本是否存在
3. `script flush`  清除内存中所有的脚本
4. `script kill`  杀掉正在执行的lua脚本
