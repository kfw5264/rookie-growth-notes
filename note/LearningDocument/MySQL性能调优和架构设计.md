# MySQL性能调优和架构设计

## 范式化设计
- 第一范式(1NF)：所有属性不可再分
- 第二范式(2NF)：实体属性完全依赖于主键
- 第三范式(3NF)：一个数据库不能包含其他数据库中的非主键关键字，即每个属性跟主键偶直接关系而不是间接关系。
- 巴斯-科德范式(BCNF)：
- 第四范式(4NF)
- 第五范式(5NF，又称完美范式)

## 反范式化设计
- 为了保证性能以及查询效率适当的违反对数据库设计范式的要求。
- 为了查询性能，允许存在适当的冗余部分。

## 字段数据类型优化
1. 更小的通常更好
2. 简单就好
3. 尽量避免使用`null`：`null`值占用更多空间，且索引统计更加复杂。

## 命名规范
- 可读性原则
- 使用小写字母或者数字
- 不适用复数英语单词
- 禁用保留字
- 索引命名：主键`pk_xxx`, 唯一键`uk_xxx`, 普通索引`idx_xxx`

## MySQL索引
> 帮助数据库高效获取数据的数据结构。`InnoDB`存储引擎支持以下几种常见索引：B+索引，全文索引，哈希索引(内部)。

> B树跟B+树的区别:    
> 1. B数非叶子节点也会存储数据，而B+树只在叶子节点存储数据。  
> 2. B+树叶子节点之间会有指针的指向。       
> MySQL中选用B+树而不是B树的原因：      
> - B树每个节点都存储数据，每次查询的大小固定，就会造成每次查询返回的数据条数变少，相同数据规模下情况下B树会增加IO次数，而B+树则数据量较小，一次可以返回多条记录，IO次数少。
> - 范围查询B+树明显优于B树。

### B+索引

#### 聚簇索引/聚集索引
将表的主键用来构建一个B+树，并且将整张表的行记录保存在叶子节点中。

#### 二级索引/辅助索引
- 二级索引叶子节点除了保存键值之外还会保存一个书签(主键)，不包含所有数据。    
- 二级索引不保存所有数据的原因：每个二级索引都保存全部数据会导致占用空间过大，且每次修改数据都要修改对应二级索引中的数据，影响效率。    

#### 回表
- 通过二级索引获取主键，然后通过主键来找到完整的行记录。       
- 回表次数过多会影响SQL查询效率，实际操作过程中应该尽量避免回表。     

#### 联合索引/复合索引
- 表中多个列组合起来创建索引。多个列优先左边开始排列。   
- 最佳左前缀。    
- 为了避免索引过多，可以通过联合索引来较少索引数量。       

#### 覆盖索引    
通过二级索引可以查询到的数据可以不用通过回表再次查询聚簇索引。    

### 哈希索引

- **自适应哈希索引：**B+树的高度一般是1-3层，所以一般查询需要1-3次IO。如果有一些热数据，每次都需要3次IO会导致效率低下，所以此时MySQL内部会采用哈希索引。 
- 哈希索引在5.7中默认开启，`innodb_adaptive_hash_index`来考虑是启用或是禁用此特性。 



```sql
> show engine innodb status;  # 查看状态
# Status列中下面这段是innodb中哈希索引相关的信息
...
-------------------------------------
INSERT BUFFER AND ADAPTIVE HASH INDEX
-------------------------------------
Ibuf: size 1, free list len 0, seg size 2, 0 merges
merged operations:
 insert 0, delete mark 0, delete 0
discarded operations:
 insert 0, delete mark 0, delete 0
Hash table size 34679, node heap has 3 buffer(s)
Hash table size 34679, node heap has 2 buffer(s)
Hash table size 34679, node heap has 6 buffer(s)
Hash table size 34679, node heap has 1 buffer(s)
Hash table size 34679, node heap has 9 buffer(s)
Hash table size 34679, node heap has 2 buffer(s)
Hash table size 34679, node heap has 2 buffer(s)
Hash table size 34679, node heap has 4 buffer(s)
0.00 hash searches/s, 0.00 non-hash searches/s
...
```

## 高性能索引创建策略

### 索引在查询中的作用

1. 一个索引就是一个B+树，索引让我们的查询可以快速定位和扫描到我们的 数据记录上面，加快查询的速度。 
2. 一个SELECT语句在执行过程中最多只能使用一个二级索引，即使WHERE条件中用了多个二级索引。 

### 创建策略

1. 索引列尽量小

2. 索引的选择性/离散性：不重复的索引值和数据表记录总数比值越高查询效率越高，即重复数据越少查询效率越高。 

   > 如果整个数据表中数据有10000条，索引列重复的记录只有十条，那么相当于只需要在这10条中查询，重复的越多那么需要过滤的数据越多。   
   >
   > `SELECT COUNT(DISTINCT key)/COUNT(*) FROM tableName`，返回的结果越大说明重复记录越少。  

3. 前缀索引：很长的`VARCHAR`类型数据需要进行前缀索引。`ALTER TABLE tableName add key/index (column(x))`，其中x表示索引取前几个字符。

   > 前缀索引无法引用于`ORDER BY`以及`GROUP BY`，也无法做覆盖索引。因为包含的数据本来就不全。
   >
   > 判断前缀索引的截取长度的时候需要考虑离散型：`SELECT COUNT(DISTINCT LEFT(column, x))/COUNT(*) from tableName`，其中x表示需要截取的长度，返回值越大表示离散度越高。 

4. 后缀索引：MySQL不支持后缀索引。可以用于邮箱等数据。  

5. 联合索引：多列联合建立索引。建立索引只为搜索、排序或分组的列创建索引。 

   1. 选择性最高的列放在最前面。  
   2. 根据运行频次最高的列调整顺序。
   3. 优化性能时可以创建相同列但不同顺序的索引以满足不同的查询情况。 

### 三星索引

> 对于一个查询来说，三星索引可能是其最好的索引。

1. 索引将相关的记录放在一起则获得一星，尽量保证查询的数据连续且范围尽量窄，优先级第二；
2. 索引中的数据顺序跟查询排序一致（排序星），避免数据查出之后再次排序，优先级最低；
3. 索引中的列包含查询所需的所有的列则获得三星（宽索引性），避免回表，优先级最高。



## MySQL调优

### MySQL调优金字塔

![image-20230703235227563](images\MySQL调优金字塔.png)







